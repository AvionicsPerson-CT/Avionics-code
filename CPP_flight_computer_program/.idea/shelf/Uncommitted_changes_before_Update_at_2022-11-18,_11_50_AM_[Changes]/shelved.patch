Index: include/RFM95W.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef CPP_FLIGHT_COMPUTER_PROGRAM_RFM95W_H\n#define CPP_FLIGHT_COMPUTER_PROGRAM_RFM95W_H\n\n// YOU CAN ONLY HAVE 2 INSTANCES OF THIS OBJ AT 1 TIME (3 IF MEGA)\n/*\n    LoRa packet format:\n        8 symbol PREAMBLE\n        Explicit header with header CRC (default CCITT, handled internally by the radio)\n        4 octets HEADER: (TO, FROM, ID, FLAGS)\n        0 to 251 octets DATA\n        CRC (default CCITT, handled internally by the radio)\n\n    LoRa Chirp Options:\n        typedef enum\n        {\n            Bw125Cr45Sf128 = 0,\t   //< Bw = 125 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on. Default medium range\n            Bw500Cr45Sf128,\t           //< Bw = 500 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on. Fast+short range\n            Bw31_25Cr48Sf512,\t   //< Bw = 31.25 kHz, Cr = 4/8, Sf = 512chips/symbol, CRC on. Slow+long range\n            Bw125Cr48Sf4096,           //< Bw = 125 kHz, Cr = 4/8, Sf = 4096chips/symbol, CRC on. Slow+long range\n        } ModemConfigChoice;\n*/\n#include <RH_RF95.h>\n#include <memory>\n#include <tuple>\n\nclass RFM95W\n{\npublic:\n    enum Mode\n    {\n        RX,\n        TX,\n        IDLE\n    };\n\n    RFM95W(const uint8_t &Slave, const uint8_t &Interrupt, const uint8_t &Reset, const Mode &Type = Mode::IDLE);\n\n    // core\n    bool Send(const char *Data, const uint16_t &Time_Out_TX, const uint16_t &Time_Out_RX) const;\n\n    std::tuple<bool, const char*> Receive();\n    // Time_Out in milliseconds\n    std::tuple<bool, const char*> Receive(const uint8_t &Time_Out);\n\n    // util\n    uint16_t Max_Message_Length() const;\n\n\n    // Settings\n    // It is very important therefore, that if you are using the RH_RF95 driver with another SPI based deviced,\n    // that you disable interrupts while you transfer data to and from that other device.\n    // Use cli() to disable interrupts and sei() to reenable them.\n    bool Set_Frequency(const float &Frequency);\n    // default RH_RF95::Bw125Cr45Sf128\n    void Set_Modem_Config_Choice(const uint8_t &Index);\n    // in bytes\n    void Set_Preamble_Length(const uint8_t &Length);\n    void Switch_Mode(const Mode &Type);\n\n\n    RFM95W() = delete;\n    RFM95W(const RFM95W &RHS) = delete;\n\nprivate:\n    std::unique_ptr<RH_RF95> m_RF95;\n    uint8_t m_RST;\n    uint16_t m_Max_Message_Length{};\n};\n\n#endif //CPP_FLIGHT_COMPUTER_PROGRAM_RFM95W_H
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/RFM95W.h b/include/RFM95W.h
--- a/include/RFM95W.h	(revision 0cb6c5360139bd7a622ca54dd38d6c4d78d0c356)
+++ b/include/RFM95W.h	(date 1668793833295)
@@ -61,6 +61,100 @@
     RFM95W() = delete;
     RFM95W(const RFM95W &RHS) = delete;
 
+private:
+    std::unique_ptr<RH_RF95> m_RF95;
+    uint8_t m_RST;
+    uint16_t m_Max_Message_Length{};
+    const std::string m_Handshake{"Received"};
+};
+
+/*
+ * =================================================================
+ *                          UDP
+ * =================================================================
+ */
+class RFM95W_TX
+{
+public:
+    enum Mode
+    {
+        RX,
+        TX,
+        IDLE
+    };
+
+    RFM95W_TX(const uint8_t &Slave, const uint8_t &Interrupt, const uint8_t &Reset, const Mode &Type = Mode::IDLE);
+
+    // core
+    bool Send(const char *Data, const uint16_t &Time_Out_TX, const uint16_t &Time_Out_RX) const;
+
+    std::tuple<bool, const char*> Receive();
+    // Time_Out in milliseconds
+    std::tuple<bool, const char*> Receive(const uint8_t &Time_Out);
+
+    // util
+    uint16_t Max_Message_Length() const;
+
+
+    // Settings
+    // It is very important therefore, that if you are using the RH_RF95 driver with another SPI based deviced,
+    // that you disable interrupts while you transfer data to and from that other device.
+    // Use cli() to disable interrupts and sei() to reenable them.
+    bool Set_Frequency(const float &Frequency);
+    // default RH_RF95::Bw125Cr45Sf128
+    void Set_Modem_Config_Choice(const uint8_t &Index);
+    // in bytes
+    void Set_Preamble_Length(const uint8_t &Length);
+    void Switch_Mode(const Mode &Type);
+
+
+    RFM95W_TX() = delete;
+    RFM95W_TX(const RFM95W_TX &RHS) = delete;
+
+private:
+    std::unique_ptr<RH_RF95> m_RF95;
+    uint8_t m_RST;
+    uint16_t m_Max_Message_Length{};
+};
+
+class RFM95W_RX
+{
+public:
+    enum Mode
+    {
+        RX,
+        TX,
+        IDLE
+    };
+
+    RFM95W_RX(const uint8_t &Slave, const uint8_t &Interrupt, const uint8_t &Reset, const Mode &Type = Mode::IDLE);
+
+    // core
+    bool Send(const char *Data, const uint16_t &Time_Out_TX, const uint16_t &Time_Out_RX) const;
+
+    std::tuple<bool, const char*> Receive();
+    // Time_Out in milliseconds
+    std::tuple<bool, const char*> Receive(const uint8_t &Time_Out);
+
+    // util
+    uint16_t Max_Message_Length() const;
+
+
+    // Settings
+    // It is very important therefore, that if you are using the RH_RF95 driver with another SPI based deviced,
+    // that you disable interrupts while you transfer data to and from that other device.
+    // Use cli() to disable interrupts and sei() to reenable them.
+    bool Set_Frequency(const float &Frequency);
+    // default RH_RF95::Bw125Cr45Sf128
+    void Set_Modem_Config_Choice(const uint8_t &Index);
+    // in bytes
+    void Set_Preamble_Length(const uint8_t &Length);
+    void Switch_Mode(const Mode &Type);
+
+
+    RFM95W_RX() = delete;
+    RFM95W_RX(const RFM95W_RX &RHS) = delete;
+
 private:
     std::unique_ptr<RH_RF95> m_RF95;
     uint8_t m_RST;
Index: src/RFM95W.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"RFM95W.h\"\n\nRFM95W::RFM95W(const uint8_t &Slave, const uint8_t &Interrupt, const uint8_t &Reset, const Mode &Type)\n{\n    m_RF95 = std::make_unique<RH_RF95>(Slave, Interrupt);\n\n    // default configuration: 434.0MHz, 13dBm, Bw = 125 kHz, Cr = 4/5, Sf = 128chips/symbol(2^7), CRC on\n    m_RF95->init();\n\n    Switch_Mode(Type);\n\n    m_Max_Message_Length = m_RF95->maxMessageLength();\n\n    m_RST = Reset;\n\n\n}\n\nbool RFM95W::Send(const char *Data, const uint16_t &Time_Out_TX, const uint16_t &Time_Out_RX) const\n{\n    // 'atoi()' used to convert a string to an integer value,\n    // but function will not report conversion errors; consider using 'strtoul' instead\n    // const uint8_t Message = std::atoi(Data);\n\n    // returns false if message too long\n\n    // need to double check to make sure sizeof(*Data) does not return sizeof(Data_ptr)\n    m_RF95->send(reinterpret_cast<const uint8_t*>(Data), sizeof(*Data));\n\n    if(m_RF95->waitPacketSent(Time_Out_TX) == true)\n    {\n        // TODO hand shake\n        if (m_RF95->waitAvailableTimeout(Time_Out_RX) == true)\n        {\n            uint8_t Buffer[m_Max_Message_Length];\n            uint8_t Length = sizeof(Buffer);\n\n            // this hand shake could happen forever\n            if (m_RF95->recv(Buffer, &Length) == true)\n            {\n                // this is not necessary if RX is only performing handshake\n                return strcmp(reinterpret_cast<const char *>(Buffer), \"Received\") == 0;\n            }\n            return false;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    return false;\n}\n\nstd::tuple<bool,  const char*> RFM95W::Receive()\n{\n    uint8_t Buffer[m_Max_Message_Length];\n    uint8_t Length = sizeof(Buffer);\n\n    m_RF95->waitAvailable();\n\n    if(m_RF95->recv(Buffer, &Length) == true)\n    {\n        // TODO perform handshake\n        m_RF95->send(reinterpret_cast<const uint8_t*>(\"Received\"), sizeof(\"Received\"));\n\n        // this type cast is very funky, functionally the exact same as (const char*) var, but dangerous regardless\n        return std::make_tuple(true, reinterpret_cast<const char*>(Buffer));\n    }\n    else\n    {\n        return std::make_tuple(false, \"Failed to receive message\");\n    }\n}\n\n\nstd::tuple<bool,  const char*> RFM95W::Receive(const uint8_t &Time_Out)\n{\n    uint8_t Buffer[m_Max_Message_Length];\n    // isn't this just m_Max_Message_Length + 1\n    uint8_t Length = sizeof(Buffer);\n\n    if(m_RF95->waitAvailableTimeout(Time_Out) == true)\n    {\n        if(m_RF95->recv(Buffer, &Length) == true)\n        {\n            // TODO perform handshake\n            m_RF95->send(reinterpret_cast<const uint8_t*>(\"Received\"), sizeof(\"Received\"));\n\n            // this type cast is very funky, functionally the exact same as (const char*) var, but dangerous regardless\n            return std::make_tuple(true, reinterpret_cast<const char*>(Buffer));\n        }\n        else\n        {\n            return std::make_tuple(false, \"Failed to receive message\");\n        }\n    }\n    else\n    {\n        // timed out\n        return std::make_tuple(false, \"Timed out\");\n    }\n\n}\n\nbool RFM95W::Set_Frequency(const float &Frequency)\n{\n    return m_RF95->setFrequency(Frequency);\n}\n\nvoid RFM95W::Set_Modem_Config_Choice(const uint8_t &Index)\n{\n    switch(Index)\n    {\n        case 0:\n            // this is default already\n            m_RF95->setModemConfig(RH_RF95::Bw125Cr45Sf128);\n            break;\n        case 1:\n            m_RF95->setModemConfig(RH_RF95::Bw500Cr45Sf128);\n            break;\n        case 2:\n            m_RF95->setModemConfig(RH_RF95::Bw31_25Cr48Sf512);\n            break;\n        case 3:\n            m_RF95->setModemConfig(RH_RF95::Bw125Cr48Sf4096);\n            break;\n        default:\n            m_RF95->setModemConfig(RH_RF95::Bw125Cr45Sf128);\n            break;\n    }\n}\n\nvoid RFM95W::Switch_Mode(const RFM95W::Mode &Type)\n{\n    switch(Type)\n    {\n        case RFM95W::Mode::RX:\n            m_RF95->setModeRx();\n            break;\n\n        case RFM95W::Mode::TX:\n            m_RF95->setModeTx();\n            break;\n\n        case RFM95W::Mode::IDLE:\n            m_RF95->setModeIdle();\n            break;\n    }\n}\n\nuint16_t RFM95W::Max_Message_Length() const\n{\n    return m_Max_Message_Length;\n}\n\nvoid RFM95W::Set_Preamble_Length(const uint8_t &Length)\n{\n    m_RF95->setPreambleLength(Length);\n}\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/RFM95W.cpp b/src/RFM95W.cpp
--- a/src/RFM95W.cpp	(revision 0cb6c5360139bd7a622ca54dd38d6c4d78d0c356)
+++ b/src/RFM95W.cpp	(date 1668793833290)
@@ -39,7 +39,7 @@
             if (m_RF95->recv(Buffer, &Length) == true)
             {
                 // this is not necessary if RX is only performing handshake
-                return strcmp(reinterpret_cast<const char *>(Buffer), "Received") == 0;
+                return strcmp(reinterpret_cast<const char *>(Buffer), ) == 0;
             }
             return false;
         }
